<?php

declare(strict_types=1);

require __DIR__ . '/../vendor/autoload.php';

use Symfony\Component\Yaml\Yaml;

/**
 * OpenAPI Specification Fetcher
 * 
 * This script downloads the Digistore24 OpenAPI specification from the official source
 * and resolves all $ref references into a single, complete openapi.yaml file.
 * 
 * The resulting file is compatible with:
 * - Postman
 * - Swagger UI
 * - OpenAPI Generator
 * - IDE plugins
 * 
 * Usage: php scripts/fetch-openapi.php
 */

const BASE_URL = 'https://digistore24.com/api/docs/';
const OUTPUT_FILE = __DIR__ . '/../openapi.yaml';
const CACHE_DIR = __DIR__ . '/../.openapi-cache/';

class OpenAPIFetcher
{
    private array $cache = [];
    private array $processedRefs = [];
    private int $requestCount = 0;
    private const MAX_REQUESTS = 500;

    public function __construct(
        private bool $verbose = true
    ) {
        if (!is_dir(CACHE_DIR)) {
            mkdir(CACHE_DIR, 0755, true);
        }
    }

    public function fetch(): void
    {
        $this->log("🚀 Fetching OpenAPI specification from Digistore24...\n");
        
        // Download main spec
        $mainSpec = $this->downloadFile(BASE_URL . 'openapi.yaml');
        
        if (!$mainSpec) {
            $this->error("Failed to download main OpenAPI specification");
            exit(1);
        }
        
        $this->log("✓ Main specification downloaded\n");
        
        // Parse YAML
        try {
            $data = Yaml::parse($mainSpec);
        } catch (\Exception $e) {
            $this->error("Failed to parse YAML: " . $e->getMessage());
            exit(1);
        }
        
        $this->log("✓ YAML parsed successfully\n");
        $this->log("📦 Resolving references...\n");
        
        // Resolve all $ref
        $resolved = $this->resolveReferences($data);
        
        $this->log("✓ All references resolved ({$this->requestCount} files processed)\n");
        $this->log("💾 Writing complete specification...\n");
        
        // Write to file
        try {
            $yaml = Yaml::dump($resolved, 10, 2, Yaml::DUMP_MULTI_LINE_LITERAL_BLOCK);
        } catch (\Exception $e) {
            $this->error("Failed to emit YAML: " . $e->getMessage());
            exit(1);
        }
        
        // Add header comment
        $header = <<<YAML
# Digistore24 API - Complete OpenAPI Specification
# 
# This file was automatically generated by scripts/fetch-openapi.php
# Source: https://digistore24.com/api/docs/openapi.yaml
# Generated: {DATE}
# 
# All \$ref references have been resolved into this single file.
# Compatible with Postman, Swagger UI, and OpenAPI Generator.
#
# DO NOT EDIT THIS FILE MANUALLY - regenerate using:
# php scripts/fetch-openapi.php
#
---

YAML;
        
        $header = str_replace('{DATE}', date('Y-m-d H:i:s T'), $header);
        $output = $header . $yaml;
        
        if (file_put_contents(OUTPUT_FILE, $output) === false) {
            $this->error("Failed to write output file");
            exit(1);
        }
        
        $size = number_format(filesize(OUTPUT_FILE) / 1024, 2);
        $this->log("✅ Complete OpenAPI specification written to: openapi.yaml ({$size} KB)\n");
        $this->log("\n🎉 Done! You can now use this file with Postman or any OpenAPI tool.\n");
    }

    private function resolveReferences(mixed $data): mixed
    {
        if (is_array($data)) {
            // Check for $ref
            if (isset($data['$ref'])) {
                return $this->resolveRef($data['$ref']);
            }
            
            // Recursively resolve all array elements
            $resolved = [];
            foreach ($data as $key => $value) {
                $resolved[$key] = $this->resolveReferences($value);
            }
            return $resolved;
        }
        
        return $data;
    }

    private function resolveRef(string $ref): mixed
    {
        // Prevent circular references
        if (isset($this->processedRefs[$ref])) {
            $this->log("  ⚠ Circular reference detected: {$ref}\n", 'yellow');
            return ['description' => "Circular reference to {$ref}"];
        }
        
        $this->processedRefs[$ref] = true;
        
        // Parse reference
        if (strpos($ref, '#/') === 0) {
            // Internal reference - should not happen in resolved spec
            $this->log("  ⚠ Internal reference: {$ref}\n", 'yellow');
            return ['description' => "Internal reference: {$ref}"];
        }
        
        // External reference
        if ($this->requestCount >= self::MAX_REQUESTS) {
            $this->error("Maximum request limit reached ({$this->requestCount})");
            exit(1);
        }
        
        $this->log("  → Fetching: {$ref}\n");
        
        // Download referenced file
        $url = BASE_URL . $ref;
        $content = $this->downloadFile($url);
        
        if (!$content) {
            $this->log("  ✗ Failed to download: {$ref}\n", 'red');
            return ['description' => "Failed to resolve reference: {$ref}"];
        }
        
        $this->requestCount++;
        
        // Parse YAML or JSON
        try {
            if (str_ends_with($ref, '.yaml') || str_ends_with($ref, '.yml')) {
                $data = Yaml::parse($content);
            } elseif (str_ends_with($ref, '.json')) {
                $data = json_decode($content, true);
            } else {
                $this->log("  ✗ Unknown file type: {$ref}\n", 'red');
                return ['description' => "Unknown file type: {$ref}"];
            }
        } catch (\Exception $e) {
            $this->log("  ✗ Failed to parse: {$ref} - {$e->getMessage()}\n", 'red');
            return ['description' => "Failed to parse: {$ref}"];
        }
        
        if ($data === null) {
            $this->log("  ✗ Failed to parse: {$ref}\n", 'red');
            return ['description' => "Failed to parse: {$ref}"];
        }
        
        // Recursively resolve nested references
        return $this->resolveReferences($data);
    }

    private function downloadFile(string $url): string|false
    {
        // Check cache
        $cacheKey = md5($url);
        $cacheFile = CACHE_DIR . $cacheKey;
        
        if (file_exists($cacheFile) && (time() - filemtime($cacheFile)) < 3600) {
            $this->log("  ↻ Using cached: {$url}\n", 'blue');
            return file_get_contents($cacheFile);
        }
        
        // Download
        $context = stream_context_create([
            'http' => [
                'method' => 'GET',
                'header' => "User-Agent: Digistore24-PHP-SDK-OpenAPI-Fetcher/1.0\r\n",
                'timeout' => 30,
            ],
        ]);
        
        $content = @file_get_contents($url, false, $context);
        
        if ($content !== false) {
            // Cache the result
            file_put_contents($cacheFile, $content);
        }
        
        return $content;
    }

    private function log(string $message, string $color = 'white'): void
    {
        if (!$this->verbose) {
            return;
        }
        
        $colors = [
            'red' => "\033[31m",
            'green' => "\033[32m",
            'yellow' => "\033[33m",
            'blue' => "\033[34m",
            'white' => "\033[37m",
            'reset' => "\033[0m",
        ];
        
        echo ($colors[$color] ?? '') . $message . ($colors['reset'] ?? '');
    }

    private function error(string $message): void
    {
        $this->log("❌ ERROR: {$message}\n", 'red');
    }
}

// Check for required dependencies
if (!class_exists('Symfony\Component\Yaml\Yaml')) {
    echo "❌ ERROR: Symfony YAML component is not installed.\n";
    echo "\n";
    echo "Install it with:\n";
    echo "  composer require --dev symfony/yaml\n";
    echo "\n";
    exit(1);
}

// Run
$fetcher = new OpenAPIFetcher(verbose: true);
$fetcher->fetch();
